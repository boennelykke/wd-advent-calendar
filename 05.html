<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Atmospheric Interactive Christmas Tree</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000510; /* Deep midnight blue */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #4aaef7;
            font-size: 1.2rem;
            letter-spacing: 2px;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }
        .ui-overlay {
            position: absolute;
            bottom: 30px;
            left: 0;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.5);
            pointer-events: none;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
    </style>
</head>
<body>

    <div id="loading">GENERATING LIGHTS...</div>
    <div id="canvas-container"></div>
    <div class="ui-overlay">Hover to energize â€¢ Drag to rotate</div>

    <!-- Three.js and Post Processing -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- Configuration ---
        const CONFIG = {
            particleCount: 15000,
            treeHeight: 45,
            baseRadius: 18,
            spiralTurns: 12,
            bloomStrength: 1.5,
            bloomRadius: 0.4,
            bloomThreshold: 0.1,
            colorBase: new THREE.Color('#0f4c3a'), // Deep Green
            colorLight: new THREE.Color('#d4af37'), // Gold
            colorHot: new THREE.Color('#ffffff'),   // White/Cyan
            bgColor: new THREE.Color('#000510')
        };

        // --- Scene Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = CONFIG.bgColor;
        scene.fog = new THREE.FogExp2(CONFIG.bgColor, 0.025);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 200);
        camera.position.set(0, 15, 60);

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        container.appendChild(renderer.domElement);

        // --- Controls ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2 - 0.05; // Prevent going below ground
        controls.minDistance = 20;
        controls.maxDistance = 100;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // --- Raycaster for "Mouse World Position" ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const planeGeometry = new THREE.PlaneGeometry(200, 200);
        const planeMaterial = new THREE.MeshBasicMaterial({ visible: false });
        const interactionPlane = new THREE.Mesh(planeGeometry, planeMaterial);
        // Plane faces camera mostly
        interactionPlane.rotation.x = 0; 
        scene.add(interactionPlane);

        // --- Shader Material ---
        // This simulates the behavior of particles on the GPU
        const particleVertexShader = `
            uniform float uTime;
            uniform float uPixelRatio;
            uniform vec3 uMouseWorld;
            
            attribute float aSize;
            attribute float aRandom;
            attribute float aSpeed;
            attribute vec3 aColor;
            
            varying vec3 vColor;
            varying float vDistToMouse;

            void main() {
                vec3 pos = position;

                // Gentle organic movement (Wind)
                float sway = sin(uTime * aSpeed + pos.y * 0.5) * 0.2;
                pos.x += sway;
                pos.z += sway * 0.5;

                // Mouse Interaction (Repel/Excite)
                // We calculate distance to the mouse cursor in world space
                float dist = distance(pos, uMouseWorld);
                vDistToMouse = dist; // Pass to fragment

                // "Excitement" effect if near mouse
                float influenceRadius = 12.0;
                float excitement = smoothstep(influenceRadius, 0.0, dist);
                
                // Expand outward slightly when excited
                vec3 dir = normalize(pos - uMouseWorld);
                pos += dir * excitement * 1.5;

                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_Position = projectionMatrix * mvPosition;

                // Size attenuation (bigger when closer to camera)
                // Plus bonus size when excited
                float outputSize = aSize * (1.0 + excitement * 1.5);
                gl_PointSize = outputSize * uPixelRatio * (200.0 / -mvPosition.z);
                
                // Pass color
                vColor = aColor;
            }
        `;

        const particleFragmentShader = `
            uniform float uTime;
            varying vec3 vColor;
            varying float vDistToMouse;

            void main() {
                // Circular particle shape
                float r = distance(gl_PointCoord, vec2(0.5));
                if (r > 0.5) discard;

                // Soft glow edge
                float glow = 1.0 - (r * 2.0);
                glow = pow(glow, 1.5);

                // Interaction Color Shift
                // If close to mouse, shift towards bright white/cyan
                float influenceRadius = 12.0;
                float excitement = smoothstep(influenceRadius, 0.0, vDistToMouse);
                
                vec3 finalColor = mix(vColor, vec3(0.8, 0.95, 1.0), excitement);
                
                // Twinkle effect
                float twinkle = sin(uTime * 3.0 + vDistToMouse) * 0.5 + 0.5;
                finalColor += twinkle * 0.2;

                // Increase brightness for bloom interaction
                finalColor *= (1.0 + excitement * 2.0);

                gl_FragColor = vec4(finalColor, glow);
            }
        `;

        // --- Geometry Generation ---
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const colors = [];
        const sizes = [];
        const randomness = [];
        const speeds = [];

        const colorGreen = new THREE.Color(0x2e8b57);
        const colorRed = new THREE.Color(0xff3333);
        const colorGold = new THREE.Color(0xffd700);

        // 1. Tree Lights
        for (let i = 0; i < CONFIG.particleCount; i++) {
            // Conical Spiral
            const t = i / CONFIG.particleCount; // 0 to 1
            const angle = t * Math.PI * 2 * CONFIG.spiralTurns;
            
            // Radius gets smaller as we go up
            const currentRadius = (1 - t) * CONFIG.baseRadius;
            
            // Add some noise to radius for volume
            const randomRadius = currentRadius + (Math.random() - 0.5) * 2.0;

            const x = Math.cos(angle) * randomRadius;
            const y = t * CONFIG.treeHeight - (CONFIG.treeHeight / 2) + 5; // Offset y
            const z = Math.sin(angle) * randomRadius;

            positions.push(x, y, z);

            // Logic for Color Distribution
            // Mostly green, some gold, rare red
            const colorRand = Math.random();
            let c;
            let size = 0.5 + Math.random() * 0.5;

            if (colorRand > 0.9) {
                c = colorRed; // Ornaments
                size *= 1.5;
            } else if (colorRand > 0.75) {
                c = colorGold; // Lights
                size *= 1.2;
            } else {
                c = colorGreen; // Needles/Tree structure
                // Vary green slightly
                c = c.clone().offsetHSL(0, 0, (Math.random() - 0.5) * 0.1);
            }

            colors.push(c.r, c.g, c.b);
            sizes.push(size);
            randomness.push(Math.random());
            speeds.push(0.5 + Math.random());
        }

        // 2. Star on Top
        const starPoints = 50;
        for(let i=0; i<starPoints; i++) {
            positions.push(
                (Math.random() - 0.5) * 1.5,
                CONFIG.treeHeight / 2 + 5 + Math.random() * 1.5,
                (Math.random() - 0.5) * 1.5
            );
            colors.push(1.0, 1.0, 0.8); // Bright yellowish white
            sizes.push(2.0);
            randomness.push(Math.random());
            speeds.push(0.0);
        }

        // 3. Falling Snow / Ambient Dust
        const snowCount = 2000;
        const snowRange = 80;
        for(let i=0; i<snowCount; i++) {
            positions.push(
                (Math.random() - 0.5) * snowRange,
                (Math.random() - 0.5) * snowRange + 20,
                (Math.random() - 0.5) * snowRange
            );
            colors.push(0.8, 0.8, 1.0); // Blueish white
            sizes.push(0.3);
            randomness.push(Math.random());
            speeds.push(0.2 + Math.random() * 0.5);
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('aColor', new THREE.Float32BufferAttribute(colors, 3));
        geometry.setAttribute('aSize', new THREE.Float32BufferAttribute(sizes, 1));
        geometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randomness, 1));
        geometry.setAttribute('aSpeed', new THREE.Float32BufferAttribute(speeds, 1));

        // Uniforms for Shader
        const material = new THREE.ShaderMaterial({
            vertexShader: particleVertexShader,
            fragmentShader: particleFragmentShader,
            uniforms: {
                uTime: { value: 0 },
                uPixelRatio: { value: renderer.getPixelRatio() },
                uMouseWorld: { value: new THREE.Vector3(999, 999, 999) } // Default far away
            },
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        const treeSystem = new THREE.Points(geometry, material);
        scene.add(treeSystem);

        // --- Floor Reflection (Simple Grid) ---
        const gridHelper = new THREE.PolarGridHelper(40, 16, 8, 64, 0x1a2b4b, 0x0f1b2d);
        gridHelper.position.y = -CONFIG.treeHeight/2 + 5;
        scene.add(gridHelper);

        // --- Post Processing (Bloom) ---
        const renderScene = new RenderPass(scene, camera);
        
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = CONFIG.bloomThreshold;
        bloomPass.strength = CONFIG.bloomStrength;
        bloomPass.radius = CONFIG.bloomRadius;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- Interaction Logic ---
        let targetMouseWorld = new THREE.Vector3(999, 999, 999);

        function onMouseMove(event) {
            // Normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Make the interaction plane face the camera roughly so raycasting works from any angle
            interactionPlane.lookAt(camera.position);

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(interactionPlane);

            if (intersects.length > 0) {
                targetMouseWorld.copy(intersects[0].point);
            }
        }
        
        // Touch support
        function onTouchMove(event) {
            if (event.touches.length > 0) {
                const touch = event.touches[0];
                mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                
                interactionPlane.lookAt(camera.position);
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(interactionPlane);

                if (intersects.length > 0) {
                    targetMouseWorld.copy(intersects[0].point);
                }
            }
        }

        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('touchmove', onTouchMove);

        // --- Animation Loop ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const elapsedTime = clock.getElapsedTime();

            // Update Shader Uniforms
            material.uniforms.uTime.value = elapsedTime;

            // Smoothly interpolate mouse position for fluid effect
            const currentMouse = material.uniforms.uMouseWorld.value;
            currentMouse.lerp(targetMouseWorld, 0.1); 

            // Rotate tree slightly for ambient movement
            treeSystem.rotation.y = Math.sin(elapsedTime * 0.1) * 0.1;

            // Snow falling effect simulation logic (manual position update for wrapping)
            // Note: In a pure shader approach we'd do this in GLSL, but wrapping is easier in JS for simplicity
            // However, our shader handles wind. We will let the shader handle visuals.
            
            // Auto-rotate camera if not interacting
            controls.update();

            composer.render();
        }

        // Remove loading text
        document.getElementById('loading').style.opacity = 0;

        // Resize handling
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            material.uniforms.uPixelRatio.value = renderer.getPixelRatio();
        });

        animate();

    </script>
</body>
</html>
