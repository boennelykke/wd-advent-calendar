<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Workday Pattern Creator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        body {
            background-color: white; 
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        /* Glassmorphism card */
        .glass-panel {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(226, 232, 240, 0.8);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        /* Custom Scrollbar for dropdowns */
        select {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 0.5rem center;
            background-repeat: no-repeat;
            background-size: 1.5em 1.5em;
            appearance: none;
        }

        .canvas-container {
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.2), 0 10px 10px -5px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease;
        }
        
        /* Animation for generation */
        @keyframes popIn {
            0% { transform: scale(0.95); opacity: 0.5; }
            100% { transform: scale(1); opacity: 1; }
        }
        .animate-pop {
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center p-4 md:p-8 text-slate-800">

    <div class="w-full max-w-4xl flex flex-col gap-6">
        
        <!-- Header & Controls -->
        <div class="glass-panel rounded-2xl p-6 md:p-8 w-full">
            <h1 class="text-3xl md:text-4xl font-bold text-center mb-2 text-indigo-900 drop-shadow-sm flex items-center justify-center gap-3">
                <img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcStX7QE9_t8rE6giq0HbgsV2EYAWxqz7o1U1g&s" class="h-10 w-auto rounded-md" alt="Workday Logo">
                Workday Pattern Creator
            </h1>
            <p class="text-center text-slate-600 mb-6">Mix gradients and diverse styles to create unique designs.</p>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                <!-- Color Theme Dropdown -->
                <div class="relative">
                    <label class="block text-sm font-semibold text-slate-700 mb-2">Background Gradient</label>
                    <select id="themeSelect" class="w-full p-3 bg-white border border-slate-300 rounded-xl focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 outline-none shadow-sm text-slate-700 font-medium cursor-pointer transition-all">
                        <option value="morning">Morning</option>
                        <option value="day">Day</option>
                        <option value="night">Night</option>
                        <option value="morning_crop_2">Morning crop 2</option>
                        <option value="day_crop_2">Day crop 2</option>
                        <option value="night_crop_2">Night crop 2</option>
                        <option value="night_crop_5">Night crop 5</option>
                    </select>
                </div>

                <!-- Pattern Dropdown -->
                <div class="relative">
                    <label class="block text-sm font-semibold text-slate-700 mb-2">Pattern</label>
                    <select id="patternSelect" class="w-full p-3 bg-white border border-slate-300 rounded-xl focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 outline-none shadow-sm text-slate-700 font-medium cursor-pointer transition-all">
                        <option value="micro">Micro Particles (Organic)</option>
                        <option value="macro">Macro Overlap (Huge)</option>
                        <option value="stripes">Rhythm Stripes (Linear)</option>
                        <option value="bauhaus">Bauhaus Geometric (Structured)</option>
                        <option value="constellation">Constellation (Connected)</option>
                    </select>
                </div>
            </div>

            <div class="flex gap-3 justify-center">
                <button onclick="generatePattern()" class="px-8 py-3 bg-indigo-600 hover:bg-indigo-700 text-white font-bold rounded-xl shadow-lg transform active:scale-95 transition-all flex items-center gap-2">
                    <i class="fa-solid fa-wand-magic-sparkles"></i> Generate
                </button>
                <button onclick="downloadPattern()" class="px-6 py-3 bg-white hover:bg-slate-50 text-indigo-900 border border-slate-200 font-bold rounded-xl shadow-md transform active:scale-95 transition-all flex items-center gap-2">
                    <i class="fa-solid fa-download"></i> Save
                </button>
            </div>
        </div>

        <!-- Canvas Display -->
        <div class="glass-panel rounded-2xl p-2 w-full flex justify-center items-center overflow-hidden canvas-container bg-white">
            <!-- Increased dimensions to 1920x1080 -->
            <canvas id="patternCanvas" width="1920" height="1080" class="w-full h-auto rounded-xl cursor-pointer" onclick="generatePattern()" title="Click to regenerate"></canvas>
        </div>
        
        <p class="text-slate-500 text-center text-sm">Click the image to regenerate instantly.</p>

    </div>

    <script>
        // Palette
        const shapePalette = [
            '#022043', '#0F2E66', '#0057AE', '#1C98E8', '#9ECFFF', 
            '#FCF8E8', '#FFF3A8', '#FDE65E', '#FEC10B', '#6FC9D3', 
            '#FFC2FD', '#AB65D0', '#FD7E00', '#FC5B05'
        ];

        // Gradients
        const themes = {
            morning: [
                { pos: 0, color: '#FD7E00' }, { pos: 0.2073, color: '#FDC5A0' }, { pos: 0.311, color: '#FAD2D6' },
                { pos: 0.4147, color: '#E6D0F5' }, { pos: 0.5183, color: '#B9C3F8' }, { pos: 0.7775, color: '#1C98E8' },
                { pos: 0.9848, color: '#0057AE' }
            ],
            day: [
                { pos: 0, color: '#FD7E00' }, { pos: 0.1996, color: '#FECB68' }, { pos: 0.2994, color: '#FDE695' },
                { pos: 0.3992, color: '#EEEEB7' }, { pos: 0.499, color: '#CAE5CE' }, { pos: 0.6487, color: '#6FC9D3' },
                { pos: 0.9481, color: '#0057AE' }
            ],
            night: [
                { pos: 0, color: '#FD7E00' }, { pos: 0.05, color: '#FDA63D' }, { pos: 0.15, color: '#FECE7A' },
                { pos: 0.25, color: '#FFDBBA' }, { pos: 0.35, color: '#EEC9DB' }, { pos: 0.45, color: '#C8A2E1' },
                { pos: 0.55, color: '#8579CF' }, { pos: 0.75, color: '#0057AE' }, { pos: 0.95, color: '#022043' }
            ],
            morning_crop_2: [
                { pos: 0, color: '#FD7E00' }, { pos: 0.40, color: '#FDC5A0' }, { pos: 0.60, color: '#FAD2D6' },
                { pos: 0.80, color: '#E6D0F5' }, { pos: 0.95, color: '#B9C3F8' }
            ],
            day_crop_2: [
                { pos: 0, color: '#FD7E00' }, { pos: 0.30, color: '#FECB68' }, { pos: 0.50, color: '#FDE695' },
                { pos: 0.65, color: '#EEEEB7' }, { pos: 0.80, color: '#CAE5CE' }, { pos: 1.0, color: '#85CFD2' }
            ],
            night_crop_2: [
                { pos: 0, color: '#FD7E00' }, { pos: 0.10, color: '#FDA63D' }, { pos: 0.30, color: '#FECE7A' },
                { pos: 0.50, color: '#FFDBBA' }, { pos: 0.70, color: '#EEC9DB' }, { pos: 0.90, color: '#C8A2E1' },
                { pos: 1.0, color: '#9C87D5' }
            ],
            night_crop_5: [
                { pos: 0, color: '#F9D5C4' }, { pos: 0.10, color: '#EEC9DB' }, { pos: 0.25, color: '#C8A2E1' },
                { pos: 0.40, color: '#8579CF' }, { pos: 0.70, color: '#0057AE' }, { pos: 1.0, color: '#022043' }
            ]
        };

        const canvas = document.getElementById('patternCanvas');
        const ctx = canvas.getContext('2d');

        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // --- DRAWING FUNCTIONS ---

        // 1. Micro Particles (Updated: Uniform Round & More Dense)
        function drawMicroPatterns(ctx) {
            // Smaller grid size = more particles
            const gridSize = 25; 
            const jitter = 12;
            const rows = Math.ceil(canvas.height / gridSize);
            const cols = Math.ceil(canvas.width / gridSize);

            for (let r = -1; r <= rows; r++) {
                for (let c = -1; c <= cols; c++) {
                    // Higher draw chance (only skip 30%)
                    if (Math.random() > 0.7) continue;

                    let x = c * gridSize + (gridSize / 2) + getRandomInt(-jitter, jitter);
                    let y = r * gridSize + (gridSize / 2) + getRandomInt(-jitter, jitter);

                    const color = shapePalette[getRandomInt(0, shapePalette.length - 1)];
                    
                    ctx.save();
                    ctx.translate(x, y);
                    
                    // Varying sizes
                    const scale = 0.2 + Math.random() * 0.6;
                    ctx.scale(scale, scale);
                    ctx.globalAlpha = 0.4 + Math.random() * 0.6; // Varying opacity
                    ctx.fillStyle = color;

                    // Draw simple circle
                    ctx.beginPath();
                    ctx.arc(0, 0, 15, 0, Math.PI * 2); // Base radius 15
                    ctx.fill();
                    
                    ctx.restore();
                }
            }
        }

        // 2. Macro Overlap (Huge overlapping shapes)
        function drawMacroPatterns(ctx) {
            const numShapes = 20;
            ctx.globalCompositeOperation = 'source-over'; 
            
            for(let i = 0; i < numShapes; i++) {
                const color = shapePalette[getRandomInt(0, shapePalette.length - 1)];
                const x = getRandomInt(0, canvas.width);
                const y = getRandomInt(0, canvas.height);
                // Significantly increased size for 1080p
                const size = getRandomInt(300, 900); 
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(getRandomInt(0, 360) * Math.PI / 180);
                
                ctx.fillStyle = color;
                ctx.globalAlpha = 0.2 + Math.random() * 0.3;

                ctx.beginPath();
                const type = Math.random();
                if (type > 0.6) {
                    ctx.arc(0, 0, size/2, 0, Math.PI * 2);
                } else if (type > 0.3) {
                    ctx.rect(-size/2, -size/2, size, size);
                } else {
                    ctx.moveTo(0, -size/2);
                    ctx.lineTo(size/2, size/2);
                    ctx.lineTo(-size/2, size/2);
                }
                ctx.fill();
                ctx.restore();
            }
        }

        // 3. Rhythm Stripes (Vertical/Diagonal bands)
        function drawStripePatterns(ctx) {
            const isDiagonal = Math.random() > 0.5;
            
            ctx.save();
            if (isDiagonal) {
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.rotate(45 * Math.PI / 180);
                ctx.translate(-canvas.width, -canvas.height); 
            }

            const drawWidth = isDiagonal ? canvas.width * 3 : canvas.width;
            const startX = isDiagonal ? -canvas.width : 0;

            let x = startX;
            while(x < drawWidth) {
                // Scaled width for hi-res
                const width = getRandomInt(20, 150); 
                const gap = getRandomInt(0, 40);
                const color = shapePalette[getRandomInt(0, shapePalette.length - 1)];
                
                ctx.fillStyle = color;
                ctx.globalAlpha = 0.4 + Math.random() * 0.6;
                ctx.fillRect(x, -canvas.height, width, canvas.height * 3);

                if (Math.random() > 0.7) {
                    ctx.fillStyle = shapePalette[getRandomInt(0, shapePalette.length - 1)];
                    ctx.globalAlpha = 1.0;
                    ctx.fillRect(x + width/2 - 2, -canvas.height, 4, canvas.height * 3);
                }

                x += width + gap;
            }
            ctx.restore();
        }

        // 4. Bauhaus Geometric (Structured)
        function drawBauhausPatterns(ctx) {
            const numShapes = 20; // Increased count
            
            for(let i=0; i<numShapes; i++) {
                const color = shapePalette[getRandomInt(0, shapePalette.length - 1)];
                const x = getRandomInt(50, canvas.width - 50);
                const y = getRandomInt(50, canvas.height - 50);
                // Increased size for hi-res
                const size = getRandomInt(100, 400); 

                ctx.save();
                ctx.translate(x, y);
                ctx.fillStyle = color;
                ctx.strokeStyle = color;
                ctx.lineWidth = size * 0.1;
                ctx.globalAlpha = 0.8;

                const shape = getRandomInt(0, 3);
                
                if (shape === 0) { // Arch
                    ctx.beginPath();
                    ctx.arc(0, 0, size/2, Math.PI, 0);
                    ctx.lineTo(size/2, size);
                    ctx.lineTo(-size/2, size);
                    ctx.closePath();
                    ctx.fill();
                } else if (shape === 1) { // Circle with hole
                    ctx.beginPath();
                    ctx.arc(0, 0, size/2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.beginPath();
                    ctx.arc(0, 0, size/4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalCompositeOperation = 'source-over';
                } else if (shape === 2) { // Stacked Rects
                    ctx.fillRect(-size/2, -size/2, size, size/3);
                    ctx.fillStyle = shapePalette[getRandomInt(0, shapePalette.length - 1)];
                    ctx.fillRect(-size/2, -size/6, size, size/3);
                    ctx.fillStyle = shapePalette[getRandomInt(0, shapePalette.length - 1)];
                    ctx.fillRect(-size/2, size/6, size, size/3);
                } else { // Quarter Circle
                    ctx.beginPath();
                    ctx.moveTo(-size/2, -size/2);
                    ctx.lineTo(size/2, -size/2);
                    ctx.lineTo(-size/2, size/2);
                    ctx.fill();
                }
                ctx.restore();
            }
        }

        // 5. Constellation (Connected)
        function drawConstellationPatterns(ctx) {
            const points = [];
            // Increased points for hi-res density
            const numPoints = 250; 

            // Generate Points
            for(let i=0; i<numPoints; i++) {
                points.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    color: shapePalette[getRandomInt(0, shapePalette.length - 1)],
                    size: getRandomInt(3, 8) // Scaled size
                });
            }

            // Draw Lines
            ctx.lineWidth = 1.5; // Thicker lines
            for(let i=0; i<points.length; i++) {
                const p1 = points[i];
                // Connect to nearest neighbors
                for(let j=i+1; j<points.length; j++) {
                    const p2 = points[j];
                    const dx = p1.x - p2.x;
                    const dy = p1.y - p2.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);

                    // Increased connection distance
                    if (dist < 180) { 
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        // Scale fade with new distance
                        ctx.strokeStyle = `rgba(255,255,255, ${1 - dist/180})`; 
                        ctx.stroke();
                    }
                }
            }

            // Draw Dots (Stars)
            for(let p of points) {
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
                ctx.fillStyle = p.color;
                ctx.globalAlpha = 1.0;
                ctx.fill();
                
                // Glow
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * 3, 0, Math.PI*2);
                ctx.fillStyle = p.color;
                ctx.globalAlpha = 0.2;
                ctx.fill();
            }
        }


        // --- MAIN GENERATION ---

        function generatePattern() {
            // Animation trigger
            canvas.classList.remove('animate-pop');
            void canvas.offsetWidth;
            canvas.classList.add('animate-pop');

            const themeKey = document.getElementById('themeSelect').value;
            const patternKey = document.getElementById('patternSelect').value;

            const gradientStops = themes[themeKey] || themes['night'];

            // 1. Background
            const gradient = ctx.createLinearGradient(0, canvas.height, 0, 0);
            gradientStops.forEach(stop => {
                gradient.addColorStop(stop.pos, stop.color);
            });
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 2. Select and Draw Pattern
            ctx.globalAlpha = 1.0;
            switch (patternKey) {
                case 'micro':
                    drawMicroPatterns(ctx);
                    break;
                case 'macro':
                    drawMacroPatterns(ctx);
                    break;
                case 'stripes':
                    drawStripePatterns(ctx);
                    break;
                case 'bauhaus':
                    drawBauhausPatterns(ctx);
                    break;
                case 'constellation':
                    drawConstellationPatterns(ctx);
                    break;
                default:
                    drawMicroPatterns(ctx);
            }
            
            // Reset for next draw
            ctx.globalAlpha = 1.0;
        }

        function downloadPattern() {
            const link = document.createElement('a');
            link.download = `pattern-${Date.now()}.png`;
            link.href = canvas.toDataURL();
            link.click();
        }

        window.onload = function() {
            document.getElementById('themeSelect').value = 'night';
            generatePattern();
        };
    </script>
</body>
</html>