<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ERP Vertical Shooter</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a2e;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            user-select: none;
        }

        canvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .top-bar {
            display: flex;
            justify-content: space-between;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #timer { color: #ffeb3b; }
        #coins { color: #4caf50; }
        #weapon-lvl { color: #2196f3; }

        #game-over-screen, #win-screen, #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
            pointer-events: auto;
        }

        .hidden { display: none !important; }

        h1 { font-size: 48px; margin-bottom: 10px; color: #fff; text-align: center; }
        p { font-size: 20px; margin-bottom: 30px; color: #ccc; text-align: center; max-width: 600px; }
        
        button {
            padding: 15px 40px;
            font-size: 24px;
            background: #e28743;
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.1s, background 0.2s;
            box-shadow: 0 4px 15px rgba(226, 135, 67, 0.4);
            font-weight: bold;
        }

        button:hover {
            transform: scale(1.05);
            background: #ff9f5e;
        }

        button:active {
            transform: scale(0.95);
        }

        /* Mobile Controls */
        #mobile-controls {
            display: none; /* Shown via JS on touch devices if needed, but we rely on touch follow mainly */
        }
    </style>
</head>
<body>

    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>

    <!-- UI Overlay -->
    <div id="ui-layer">
        <div class="top-bar">
            <div class="stat-box">Time: <span id="timer-display">60</span>s</div>
            <div class="stat-box">Weapon Level: <span id="weapon-lvl-display">1</span></div>
            <div class="stat-box">Coins: <span id="coins-display">0</span></div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen">
        <h1>Cloud Vertical</h1>
        <p>You are <strong>Workday</strong>.<br>Fly forward and blast through the legacy systems!</p>
        <p><strong>Controls:</strong><br>WASD / Arrows to Move<br>Shooting is automatic!</p>
        <p style="color: #4caf50;">Collect coins to upgrade your multi-shot!</p>
        <button id="start-btn">Launch</button>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="hidden">
        <h1 style="color: #ff5252;">System Crash</h1>
        <p>Collision detected.</p>
        <p>Coins Collected: <span id="final-score">0</span></p>
        <button id="restart-btn-fail">Reboot</button>
    </div>

    <!-- Win Screen -->
    <div id="win-screen" class="hidden">
        <h1 style="color: #69f0ae;">Deployment Successful!</h1>
        <p>You dominated the market.</p>
        <p>Coins Collected: <span id="final-score-win">0</span></p>
        <button id="restart-btn-win">Play Again</button>
    </div>

<script>
    // --- Configuration ---
    const GAME_DURATION = 60; // seconds
    const PLAYER_SPEED = 7;
    const ENEMY_BASE_SPEED = 3;
    const BULLET_SPEED = 15;
    const SPAWN_RATE_INITIAL = 800; // ms
    const SCROLL_SPEED = 4; // Speed of background objects
    
    // --- Assets ---
    const assets = {
        player: new Image(),
        enemy1: new Image(), // SAP
        enemy2: new Image(), // Oracle
    };

    assets.player.src = 'https://media.giphy.com/avatars/Workday/d6oIvpgQlKu5.png';
    assets.enemy1.src = 'https://upload.wikimedia.org/wikipedia/commons/thumb/8/8f/SAP-Logo.svg/1280px-SAP-Logo.svg.png';
    assets.enemy2.src = 'https://upload.wikimedia.org/wikipedia/commons/thumb/5/50/Oracle_logo.svg/1280px-Oracle_logo.svg.png';

    // --- Game State ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    let state = {
        running: false,
        startTime: 0,
        lastSpawn: 0,
        timeLeft: GAME_DURATION,
        coins: 0,
        player: { x: 0, y: 0, radius: 25, lastShot: 0 },
        enemies: [],
        bullets: [],
        particles: [],
        pickups: [],
        backgroundObjects: [], // Stars/Clouds
        keys: { w: false, a: false, s: false, d: false }, // Removed space
        weaponLevel: 1
    };

    // --- Resizing ---
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- Input Handling ---
    window.addEventListener('keydown', e => {
        const k = e.key.toLowerCase();
        if (state.keys.hasOwnProperty(k) || k === 'arrowup' || k === 'arrowleft' || k === 'arrowdown' || k === 'arrowright') {
            if (k === 'w' || k === 'arrowup') state.keys.w = true;
            if (k === 'a' || k === 'arrowleft') state.keys.a = true;
            if (k === 's' || k === 'arrowdown') state.keys.s = true;
            if (k === 'd' || k === 'arrowright') state.keys.d = true;
        }
    });

    window.addEventListener('keyup', e => {
        const k = e.key.toLowerCase();
        if (state.keys.hasOwnProperty(k) || k === 'arrowup' || k === 'arrowleft' || k === 'arrowdown' || k === 'arrowright') {
            if (k === 'w' || k === 'arrowup') state.keys.w = false;
            if (k === 'a' || k === 'arrowleft') state.keys.a = false;
            if (k === 's' || k === 'arrowdown') state.keys.s = false;
            if (k === 'd' || k === 'arrowright') state.keys.d = false;
        }
    });

    // Removed mousedown/mouseup listeners
    
    // Touch support for movement (simple follow)
    window.addEventListener('touchmove', (e) => {
        e.preventDefault(); // Prevent scrolling
        const touch = e.touches[0];
        // Move player towards touch
        state.player.x = touch.clientX;
        state.player.y = touch.clientY - 50; // Offset slightly above finger
    }, { passive: false });
    
    // Removed touchend listener

    // --- Game Logic ---

    function initGame() {
        state.player.x = canvas.width / 2;
        state.player.y = canvas.height - 100;
        state.enemies = [];
        state.bullets = [];
        state.pickups = [];
        state.particles = [];
        state.backgroundObjects = [];
        state.coins = 0;
        state.timeLeft = GAME_DURATION;
        state.running = true;
        state.startTime = Date.now();
        state.weaponLevel = 1;

        // Pre-populate background
        for(let i=0; i<50; i++) {
            spawnBackgroundObject(true);
        }
        
        updateUI();
        
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('game-over-screen').classList.add('hidden');
        document.getElementById('win-screen').classList.add('hidden');
        
        requestAnimationFrame(loop);
    }

    function spawnBackgroundObject(randomY = false) {
        const size = Math.random() * 3 + 1;
        state.backgroundObjects.push({
            x: Math.random() * canvas.width,
            y: randomY ? Math.random() * canvas.height : -20,
            size: size,
            speed: SCROLL_SPEED * (size / 2), // Parallax: bigger = faster
            color: `rgba(255, 255, 255, ${Math.random() * 0.3 + 0.1})`
        });
    }

    function spawnEnemy() {
        // Spawn at top
        const buffer = 50;
        const x = Math.random() * (canvas.width - 2 * buffer) + buffer;
        const y = -buffer; 

        const isOracle = Math.random() > 0.5;
        state.enemies.push({
            x: x,
            y: y,
            radius: 25,
            type: isOracle ? 'oracle' : 'sap',
            hp: isOracle ? 3 : 2, 
            speed: ENEMY_BASE_SPEED + (Math.random() * 1.5),
            maxHp: isOracle ? 3 : 2,
            wobble: Math.random() * Math.PI * 2,
            wobbleSpeed: Math.random() * 0.05 + 0.02
        });
    }

    function shoot() {
        const now = Date.now();
        // Weapon Logic based on coins
        const fireRate = Math.max(100, 350 - (state.coins * 8));
        const bulletCount = 1 + Math.floor(state.coins / 10);
        
        if (now - state.player.lastShot > fireRate) {
            state.player.lastShot = now;
            
            // Base angle is UP (-90 degrees or -PI/2)
            const baseAngle = -Math.PI / 2;
            const spread = 0.15; // Radians spread
            
            const startAngle = baseAngle - (spread * (bulletCount - 1)) / 2;
            
            for (let i = 0; i < bulletCount; i++) {
                const angle = startAngle + (spread * i);
                state.bullets.push({
                    x: state.player.x,
                    y: state.player.y - state.player.radius,
                    vx: Math.cos(angle) * BULLET_SPEED,
                    vy: Math.sin(angle) * BULLET_SPEED,
                    radius: 5,
                    life: 100 
                });
            }
        }
    }

    function createExplosion(x, y, color) {
        for(let i=0; i<10; i++) {
            state.particles.push({
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 10,
                vy: (Math.random() - 0.5) * 10,
                life: 30,
                color: color,
                size: Math.random() * 5 + 3
            });
        }
    }

    function checkCollision(c1, c2) {
        const dx = c1.x - c2.x;
        const dy = c1.y - c2.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        return dist < (c1.radius + c2.radius);
    }

    function update() {
        if (!state.running) return;

        // Timer
        const now = Date.now();
        const elapsed = (now - state.startTime) / 1000;
        state.timeLeft = Math.max(0, GAME_DURATION - elapsed);
        
        if (state.timeLeft <= 0) {
            endGame(true);
            return;
        }

        // Spawning Logic (Ramps up)
        const currentSpawnRate = Math.max(250, SPAWN_RATE_INITIAL - (elapsed * 8)); 
        if (now - state.lastSpawn > currentSpawnRate) {
            spawnEnemy();
            state.lastSpawn = now;
        }

        // Background (Parallax)
        if (Math.random() < 0.3) spawnBackgroundObject(); // Add new stars/clouds occasionally
        
        for (let i = state.backgroundObjects.length - 1; i >= 0; i--) {
            let bg = state.backgroundObjects[i];
            bg.y += bg.speed;
            if (bg.y > canvas.height) {
                state.backgroundObjects.splice(i, 1);
            }
        }

        // Player Movement
        let dx = 0;
        let dy = 0;
        if (state.keys.w) dy -= 1;
        if (state.keys.s) dy += 1;
        if (state.keys.a) dx -= 1;
        if (state.keys.d) dx += 1;

        if (dx !== 0 || dy !== 0) {
            const length = Math.sqrt(dx*dx + dy*dy);
            state.player.x += (dx / length) * PLAYER_SPEED;
            state.player.y += (dy / length) * PLAYER_SPEED;
        }

        // Keep player in bounds
        state.player.x = Math.max(state.player.radius, Math.min(canvas.width - state.player.radius, state.player.x));
        state.player.y = Math.max(state.player.radius, Math.min(canvas.height - state.player.radius, state.player.y));

        // Shooting - Auto-fire
        shoot();

        // Update Bullets
        for (let i = state.bullets.length - 1; i >= 0; i--) {
            let b = state.bullets[i];
            b.x += b.vx;
            b.y += b.vy;
            b.life--;

            if (b.life <= 0 || b.y < -50) {
                state.bullets.splice(i, 1);
                continue;
            }

            // Bullet vs Enemy
            let hit = false;
            for (let j = state.enemies.length - 1; j >= 0; j--) {
                let e = state.enemies[j];
                if (checkCollision(b, e)) {
                    hit = true;
                    e.hp--;
                    createExplosion(b.x, b.y, '#fff');
                    
                    if (e.hp <= 0) {
                        createExplosion(e.x, e.y, e.type === 'sap' ? '#008FD3' : '#F80000');
                        // Drop coin
                        state.pickups.push({
                            x: e.x,
                            y: e.y,
                            radius: 10,
                            vy: 2 // Coin falls slowly
                        });
                        state.enemies.splice(j, 1);
                    }
                    break;
                }
            }
            if(hit) state.bullets.splice(i, 1);
        }

        // Update Enemies
        for (let i = state.enemies.length - 1; i >= 0; i--) {
            let e = state.enemies[i];
            // Move down with slight wobble
            e.wobble += e.wobbleSpeed;
            e.x += Math.sin(e.wobble) * 1.5;
            e.y += e.speed;

            if (e.y > canvas.height + 50) {
                state.enemies.splice(i, 1);
                continue;
            }

            // Enemy vs Player
            if (checkCollision(state.player, e)) {
                endGame(false);
                return;
            }
        }

        // Update Pickups (Coins) - They fall down
        for (let i = state.pickups.length - 1; i >= 0; i--) {
            let p = state.pickups[i];
            
            p.y += p.vy; // Gravity for coin

            // Magnet effect if close
            const dist = Math.sqrt(Math.pow(state.player.x - p.x, 2) + Math.pow(state.player.y - p.y, 2));
            if (dist < 150) {
                p.x += (state.player.x - p.x) * 0.15;
                p.y += (state.player.y - p.y) * 0.15;
            }

            if (checkCollision(state.player, p)) {
                state.coins++;
                state.pickups.splice(i, 1);
                state.weaponLevel = 1 + Math.floor(state.coins / 10);
                updateUI();
            } else if (p.y > canvas.height + 20) {
                state.pickups.splice(i, 1);
            }
        }

        // Update Particles
        for (let i = state.particles.length - 1; i >= 0; i--) {
            let p = state.particles[i];
            p.x += p.vx;
            p.y += p.vy + 2; // Particles fall slightly relative to "flight"
            p.life--;
            p.size *= 0.9;
            if (p.life <= 0) state.particles.splice(i, 1);
        }

        updateUI();
    }

    function updateUI() {
        document.getElementById('timer-display').innerText = Math.ceil(state.timeLeft);
        document.getElementById('coins-display').innerText = state.coins;
        const bullets = 1 + Math.floor(state.coins / 10);
        document.getElementById('weapon-lvl-display').innerText = `Lvl ${bullets}`;
    }

    function endGame(win) {
        state.running = false;
        if (win) {
            document.getElementById('final-score-win').innerText = state.coins;
            document.getElementById('win-screen').classList.remove('hidden');
        } else {
            document.getElementById('final-score').innerText = state.coins;
            document.getElementById('game-over-screen').classList.remove('hidden');
        }
    }

    // --- Rendering ---

    function draw() {
        // 1. Background (Space/Clouds) - Lighter for better contrast
        const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grad.addColorStop(0, '#2b2645'); // Lighter dark blue
        grad.addColorStop(1, '#5a528a'); // Lighter purple
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw Scrolling Objects (Stars/Clouds)
        state.backgroundObjects.forEach(bg => {
            ctx.fillStyle = bg.color;
            ctx.beginPath();
            ctx.arc(bg.x, bg.y, bg.size, 0, Math.PI * 2);
            ctx.fill();
        });

        // 2. Pickups
        state.pickups.forEach(p => {
            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(0, 0, p.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#000';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('$', 0, 1);
            ctx.restore();
        });

        // 3. Enemies
        state.enemies.forEach(e => {
            ctx.save();
            ctx.translate(e.x, e.y);
            
            let img = e.type === 'sap' ? assets.enemy1 : assets.enemy2;
            try {
                // Draw slightly larger than hit radius for visual
                ctx.drawImage(img, -e.radius-5, -e.radius-5, (e.radius+5)*2, (e.radius+5)*2);
            } catch (err) {
                ctx.fillStyle = e.type === 'sap' ? 'blue' : 'red';
                ctx.beginPath();
                ctx.arc(0, 0, e.radius, 0, Math.PI * 2);
                ctx.fill();
            }

            // Simple HP dot if damaged
            if(e.hp < e.maxHp) {
                ctx.fillStyle = 'red';
                ctx.fillRect(-10, -e.radius - 8, 20, 3);
                ctx.fillStyle = '#0f0';
                ctx.fillRect(-10, -e.radius - 8, 20 * (e.hp/e.maxHp), 3);
            }

            ctx.restore();
        });

        // 4. Player
        ctx.save();
        ctx.translate(state.player.x, state.player.y);
        
        // Engine trail effect
        ctx.fillStyle = 'rgba(0, 255, 255, 0.5)';
        ctx.beginPath();
        ctx.moveTo(-5, state.player.radius - 5);
        ctx.lineTo(5, state.player.radius - 5);
        ctx.lineTo(0, state.player.radius + 15 + Math.random()*10);
        ctx.fill();

        try {
            ctx.beginPath();
            ctx.arc(0, 0, state.player.radius, 0, Math.PI * 2);
            ctx.closePath();
            ctx.clip();
            ctx.drawImage(assets.player, -state.player.radius, -state.player.radius, state.player.radius*2, state.player.radius*2);
        } catch (err) {
            ctx.fillStyle = '#e28743';
            ctx.beginPath();
            ctx.arc(0, 0, state.player.radius, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.restore();

        // 5. Bullets
        ctx.fillStyle = '#00ffcc';
        state.bullets.forEach(b => {
            ctx.beginPath();
            ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
            ctx.fill();
        });

        // 6. Particles
        state.particles.forEach(p => {
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.life / 30;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        });
    }

    function loop() {
        if (!state.running) return;
        update();
        draw();
        requestAnimationFrame(loop);
    }

    // --- Buttons ---
    document.getElementById('start-btn').onclick = initGame;
    document.getElementById('restart-btn-fail').onclick = initGame;
    document.getElementById('restart-btn-win').onclick = initGame;

    // Preload
    let loaded = 0;
    const checkLoad = () => { loaded++; };
    assets.player.onload = checkLoad;
    assets.enemy1.onload = checkLoad;
    assets.enemy2.onload = checkLoad;

</script>
</body>
</html>